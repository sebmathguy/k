package org.kframework.backend.func;

import com.google.inject.Inject;
import org.kframework.Rewriter;
import org.kframework.attributes.Source;
import org.kframework.builtin.Sorts;
import org.kframework.definition.Module;
import org.kframework.kompile.CompiledDefinition;
import org.kframework.kompile.KompileOptions;
import org.kframework.kore.K;
import org.kframework.main.GlobalOptions;
import org.kframework.utils.errorsystem.KEMException;
import org.kframework.utils.errorsystem.KExceptionManager;
import org.kframework.utils.file.FileUtil;
import org.kframework.utils.inject.DefinitionScoped;

import java.io.IOException;
import java.util.Optional;
import java.util.function.Function;

/**
 * @author: Remy Goldschmidt
 */
@DefinitionScoped
public class FuncRewriter implements Function<Module, Rewriter> {

    private final KExceptionManager kem;
    private final FileUtil files;
    private final CompiledDefinition def;
    private final DefinitionToFunc converter;

    @Inject
    public FuncRewriter(KExceptionManager kem, FileUtil files, GlobalOptions globalOptions, KompileOptions kompileOptions, CompiledDefinition def) {
        this.kem = kem;
        this.files = files;
        this.def = def;
        this.converter = new DefinitionToFunc(kem, files, globalOptions, kompileOptions);
        converter.convert(def);
    }

    @Override
    public Rewriter apply(Module module) {
        if (!module.equals(def.executionModule())) {
            throw KEMException.criticalError("Invalid module specified for rewriting.\n" +
                                             "Functional backend only supports rewriting\n" +
                                             "over the definition's main module.");
        }
        return new Rewriter() {
            @Override
            public K execute(K k, Optional<Integer> depth) {
                String ocaml = converter.convert(k, depth.orElse(-1));
                System.out.println(ocaml);
                files.saveToTemp("pgm.ml", ocaml);
                try {
                    String packages =  "zarith,str";

                    ProcessBuilder pb = files.getProcessBuilder();
                    pb = pb.command("ocamlfind",
                                    "ocamlc",
                                    "-package",
                                    packages,
                                    "-linkpkg",
                                    "-dllpath-all",
                                    "-g",
                                    "-I",
                                    files.resolveKompiled(".").getAbsolutePath(),
                                    files.resolveKompiled("def.cmo").getAbsolutePath(),
                                    "pgm.ml");

                    Process p = pb.directory(files.resolveTemp("."))
                                  .redirectError(files.resolveTemp("compile.err"))
                                  .redirectOutput(files.resolveTemp("compile.out"))
                                  .start();

                    int exit = p.waitFor();
                    if (exit != 0) {
                        System.err.println(files.loadFromTemp("compile.err"));
                        throw KEMException.criticalError("Failed to compile program to ocaml.\n" +
                                                         "See output for error information.");
                    }
                    p = files.getProcessBuilder()
                             .command("./a.out")
                             .directory(files.resolveTemp("."))
                             .redirectError(files.resolveTemp("run.err"))
                             .redirectOutput(files.resolveTemp("run.out"))
                             .start();
                    exit = p.waitFor();
                    if (exit != 0) {
                        System.err.println(files.loadFromTemp("run.err"));
                        throw KEMException.criticalError("Failed to execute program in ocaml.\n" +
                                                         "Rerun with --debug and examine the\n" +
                                                         "temporary directory for information");
                    }
                    String output = files.loadFromTemp("run.out");
                    return def.getParser(def.getParsedDefinition().getModule("KSEQ-SYMBOLIC").get(),
                                         Sorts.K(),
                                         kem)
                              .apply(output, Source.apply("generated by ocaml output"));
                } catch (IOException e) {
                    throw KEMException.criticalError("Failed to start ocamlopt: " + e.getMessage(), e);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    throw KEMException.criticalError("Ocaml process interrupted.", e);
                }
            }
        };
    }
}
